    ...    
	functions {
		// to be automaticallly generated by M2-ISA-R
		unsigned<XLEN> func_add(unsigned<XLEN> x, unsigned<XLEN> y) {
			return x + y;
		}
		unsigned<XLEN> func_mul(unsigned<XLEN> x, unsigned<XLEN> y) {
			return x * y;
		}
		unsigned<XLEN> func_mac(unsigned<XLEN> out, unsigned<XLEN> x, unsigned<XLEN> y) {
			return func_add(out, func_mul(x, y));
			return out + x * y;
		}
	}
	instructions {
		// original add
		ADD {
            encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0110011;
            assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: if(rd >=RFS || rs1 >= RFS || rs2 >= RFS) raise(0, RV_CAUSE_ILLEGAL_INSTRUCTION); else if (rd != 0) X[rd] = (unsigned<XLEN>)(X[rs1] + X[rs2]);
        }
		
		// manually partitioned add
		ADD2 {
            encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0110011;
            assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior:
			  // preamble
			  if(rd >=RFS || rs1 >= RFS || rs2 >= RFS)
			    raise(0, RV_CAUSE_ILLEGAL_INSTRUCTION);
			  if (rd == 0) break;
			  // read registers
			  unsigned<XLEN> rs1_val = X[rs1];
			  unsigned<XLEN> rs2_val = X[rs2];
			  // operation
			  unsigned<XLEN> rd_val = (unsigned<XLEN>)(rs1_val + rs2_val);
			  /* unsigned<XLEN> rd_val = func_add(rs1_val, rs2_val); */
			  // write registers
			  X[rd] = rd_val;
        }
		
		// original add
		MUL {
            encoding: 7'b0000001 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0110011;
            assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: if(rd >=RFS || rs1>=RFS || rs2>=RFS) raise(0, RV_CAUSE_ILLEGAL_INSTRUCTION); else {
                signed<MUL_LEN> res = (signed)X[rs1] * (signed)X[rs2];
                if(rd!=0) X[rd] = (unsigned<XLEN>)res;
            }
        }
		
		// manually partitioned add
		MUL2 {}  // TODO(Roman)
		
		// manually implemented mac(mul&add)
		MAC {
            encoding: ?;
            assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: if(rd >=RFS || rs1 >= RFS || rs2 >= RFS) raise(0, RV_CAUSE_ILLEGAL_INSTRUCTION); else if (rd != 0) X[rd] = (unsigned<XLEN>)(X[rd] + (signed)X[rs1] * (signed)X[rs2]);
        }
		
		// manually partitioned add
		MAC2 {}  // TODO(Roman)
		
		// Fusion approach A
		// Description: Add new CoreDSL syntax for defining mappings between instruction operands in a compact fashion. Actual fusion is implemented by pattern-matching based subgraph replacements in the metamodel.
        // Pros: TODO(Roman)
		// Cons: TODO(Roman)
		// Problem: `rd >=RFS` check (and others) will not be replaced!
		MUL_ADD {
			encoding: auto;
			assembly: "{name(rd)}, {name(rs1), {name(rs2)}}";
			behavior: {
				signed<32> temp;
				MUL(X[rd] => temp, X[rs1] => X[rs1], X[rs2] => X[rs2]);
				ADD(X[rd] => X[rd], X[rs1] => X[rd], X[rs2] => temp);
			}
		}
		
		// Fusion approach B
		// Description: Automatically partition each instruction into preamble+read+operation+write sections. Generate functions for each instructions behavior. Fused instructions are defined by composition of functions. The actual fusing is implemented trivially by inlining the functions back into the behavior.
        // Pros: TODO(Roman)
		// Cons: TODO(Roman)
		MUL_ADD {
            encoding: auto;
            assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior:
			  // preamble
			  if(rd >=RFS || rs1 >= RFS || rs2 >= RFS)
			    raise(0, RV_CAUSE_ILLEGAL_INSTRUCTION);
			  if (rd == 0) break;
			  // read registers
			  unsigned<XLEN> rs1_val = X[rs1];
			  unsigned<XLEN> rs2_val = X[rs2];
			  unsigned<XLEN> rd_val = X[rd];
			  // operation
			  // note: wb: writeback
			  unsigned<XLEN> rd_val_wb = func_mac(rd_val, rs1_val, rs2_val);
			  /* unsigned<XLEN> rd_val_wb = func_add(rd_val, func_mul(rs1_val, rs2_val)); */
			  // write registers
			  X[rd] = rd_val_wb;
        }
	}
	...